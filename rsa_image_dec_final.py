# -*- coding: utf-8 -*-
"""RSA Image Dec Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VvPOaSdAiMj9725b5-eux8vJ2F2Y_L8h
"""

# Commented out IPython magic to ensure Python compatibility.
import cv2
import numpy as np
import random
from google.colab.patches import cv2_imshow
from random import randrange, getrandbits
import matplotlib.pyplot as plt
import math
# %matplotlib inline

my_img = cv2.imread('RSA.jpg')
#plt.imshow(my_img, cmap="gray")
plt.imshow(my_img)

p = int(input("Enter a prime number p: "))
q = int(input("Enter another prime number q (not equal to p): "))

n = p * q
phi = (p - 1) * (q - 1)

def power(a,d,n):
  ans=1;
  while d!=0:
    if d%2==1:
      ans=((ans%n)*(a%n))%n
    a=((a%n)*(a%n))%n
    d>>=1
  return ans;

def generate_e(phi):
    possible_e_values = []
    for i in range(2, phi):
        if math.gcd(i, phi) == 1:
            e = i
            possible_e_values.append(e)
    return random.choice(possible_e_values)

e = generate_e(phi)

# Finding d

def gcdExtended(E,t):
  a1,a2,b1,b2,d1,d2=1,0,0,1,t,E

  while d2!=1:

    # k
    k=(d1//d2)

    #a
    temp=a2
    a2=a1-(a2*k)
    a1=temp

    #b
    temp=b2
    b2=b1-(b2*k)
    b1=temp

    #d
    temp=d2
    d2=d1-(d2*k)
    d1=temp

    D=b2

  if D>t:
    D=D%t
  elif D<0:
    D=D+t

  return D


d=gcdExtended(e,phi)
print(d)

print(my_img)

row,col=my_img.shape[0],my_img.shape[1]
enc = [[0 for x in range(3000)] for y in range(3000)]
print(col)
print(row)

# Encryption

for i in range(5,750):
  for j in range(5,1350):
    r,g,b=my_img[i,j]
    C1=power(r,e,n)
    C2=power(g,e,n)
    C3=power(b,e,n)
    enc[i][j]=[C1,C2,C3]
    C1=C1%256
    C2=C2%256
    C3=C3%256
    my_img[i,j]=[C1,C2,C3]



cv2_imshow(my_img)

# Decryption
for i in range(5,750):
  for j in range(5,1350):
    r,g,b=enc[i][j]
    M1=power(r,d,n)
    M2=power(g,d,n)
    M3=power(b,d,n)
    my_img[i,j]=[M1,M2,M3]

cv2_imshow(my_img)

